* CH 1
  Œª: expressions, variables, and abstractions

  Expression can be a variable name, an abstractions, or a combination of those things.

  Variables have no meaning or value; placeholders for inputs.

  An abstraction is a function. It is a lambda term that has a
  head (a lambda) and a body and is applied to an argument. An
  argument is an input value.

  The head of the function is a Œª (lambda) followed by a variable
  name. The body of the function is another expression. So, a
  simple function might look like this:

  Œªùë¶.ùë¶

  Œª x . x
  ^‚îÄ‚î¨‚îÄ^
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ extent of the head of the lambda.

  Œª x . x
    ^‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ the single parameter of the
            function. This binds any
            variables with the same name
            in the body of the function.

  Œª x . x
        ^‚îÄ‚îÄ body, the expression the lambda
            returns when applied. This is a
            bound variable.


  The dot (.) separates the parameters of the lambda from
  the function body.

** Beta reduction
   Let‚Äôs use the function we had above:
   Œªùë¶.ùë¶

   We‚Äôll do our first beta reduction using a number.2 We apply
   the function above to 2, substitute 2 for each bound variable
   in the body of the function, and eliminate the head:
   (Œªùë¶.ùë¶) 2

   Let‚Äôs use an example that mixes some arithmetic into our
   lambda calculus. We use the parentheses here to clarify that
   the body expression is ùë¶+1. In other words, we are not applying
   the function to the 1:
   (Œªùë¶.ùë¶ + 1)

   (Œªx.x)(Œªy.y)
   [x := (Œªy.y)] Indicate thath (Œªy.y) will be substituted for all occorrences of x.
           Œªy.y

   (Œªx.x)(Œªy.y)z

   its the same as : ((Œªx.x)(Œªy.y))z

   reduction:

   ((Œªx.x)(Œªy.y))z
   [x := (Œªy.y)]
   (Œªy.y)z
   [y := z]
         z

   Œªx.xy

   The whole abstraction can be applied to an agrument z
   1. (Œªx.xy)z
   2. (Œª[x := z].xy)
   3. zy


   "multiple" argument lambda:
   1. Œªxy.xy
   2. (Œªxy.xy) 1 2
   3. (Œªx.(Œªy.xy)) 1 2
   4. [x ‚à∂= 1]
   5. (Œªy.1y) 2
   6. [y ‚à∂= 2]
   7. 1 2

   Another one:
   1. Œªxy.xy
   2. (Œªxy.xy)(Œªz.a) 1
   3. (Œªx.(Œªy.xy)(Œªz.a)1
   4. [x := (Œªz.a)]
   5. (Œªy.(Œªz.a)y) 1
   6. [y := 1]
   7. (Œªz.a) 1
   8. [z := 1] But there is no z in the body of the functions, so we eliminate the head
   and the result is 'a'.
   9. a


   Another one:
   1. (Œªxyz.xz(yz))(Œªmn.m)(Œªp.p)

   2. (Œªx.Œªy.Œªz.xz(yz))(Œªm.Œªn.m)(Œªp.p)
      We've not reduces or applied anything here, but made the currying explicit.

   3. (Œªy.Œªz.(Œªm.Œªn.m)z(yz))(Œªp.p)
      Our first reduction step was to apply the outermost lambda,
      which was binding the x, to the first argument, (Œªm.Œªn.m).

   4. (Œªz.(Œªm.Œªn.m)(z)((Œªp.p)z))
      We applied the y and replaced the single occurrence of y with the next argument,
      the term (Œªp.p). The outermost lambda binding z is, at this point, irreducible
      because it has no argument to apply to. What remains is to go inside the terms
      one layer at a time until we find something reducible.

   5. Œªz.(Œªn.z)((Œªp.p)z)
      We can apply the lambda binding m to the argument z. The next thing we can apply is
      the lambda binding n to the lambda term ((Œªp.p)z).

   6. Œªz.z
      In the final step, the reduction takes a turn that might look
      slightly odd. Here the outermost, leftmost reducible term
      is Œªn.z applied to the entirety of ((Œªp.p)z). As we saw in
      an example above, it doesn‚Äôt matter what ùëú got bound to,
      Œªn.z unconditionally tosses the argument and returns z.
      So, we are left with an irreducible lambda expression.



** Combinators

   A combinator is a lambda term with no free variables. Combi-
   nators, as the name suggests, serve only to combine the argu-

   When every term in the body occours in the head:

   1. Œªx.x
   2. Œªxy.x
   3. Œªxyz.xz(yz)

   And the following are not combinators because there's one or more free variables

   1. Œªy.x --- x is free
   2. Œªx.xz --- z is free



** Divergence

   Not all reducible lambda terms reduce neatly to a beta normal
   form. This isn‚Äôt because they‚Äôre already fully reduced, but
   rather because they diverge. Divergence here means that the
   reduction process never terminates or ends. Reducing terms
   should ordinarily converge to beta normal form, and diver-
   gence is the opposite of convergence, or normal form. Here‚Äôs
   an example of a lambda term called omega that diverges:

   1. (Œªx.xx)(Œªx.xx)
      x in the first lambda‚Äôs head becomes the second lambda

   2. ([x := (Œªx.xx)]xx)
      Using [var := expr] to denote what x has been bound to.

   3. (Œªx.xx)(Œªx.xx)
      Substituting (Œªx.xx) for each occurence of x. We're back to where
      we started and this redution process never ends
      - we can say omega diverges.

   This matters in programming because terms that diverge
   are terms that don‚Äôt produce an answer or meaningful result.
   Understanding what will terminate means understanding what
   programs will do useful work and return the answer we want.


** Summary

   The main points you should take away from this chapter are:
   ‚Ä¢ Functional programming is based on expressions that in-
   clude variables or constant values, expressions combined
   with other expressions, and functions.

   ‚Ä¢ Functions have a head and a body and are those expres-
   sions that can be applied to arguments and reduced, or
   evaluated, to a result.

   ‚Ä¢ Variables may be bound in the function declaration, and
   every time a bound variable shows up in a function, it has
   the same value.

   ‚Ä¢ All functions take one argument and return one result.

   ‚Ä¢ Functions are a mapping of a set of inputs to a set of
   outputs. Given the same input, they always return the
   same result.


** Look for Exercises in Pag. 28-31


** Definitions

   1. The lambda in lambda calculus is the greek letter Œª used
   to introduce, or abstract, arguments for binding in an expression.

   2. A lambda abstraction is an anonymous function or lambda term
   (Œªx.x + 1)

   The head of the expression, Œªx., abstracts out the term
   x + 1. We can apply it to any x and recompute different results
   for each x we applied the lambda to.

   3. Application is how one evaluates or reduces lambdas, this
   binds the argument to whatever the lambda was applied
   to. Computations are performed in lambda calculus by
   applying lambdas to arguments until you run out of ar-
   guments to apply lambdas to.

   (Œªx.x)1

   This example reduces to 1, the identity Œªx.x was applied
   to the value 1, x was bound to 1, and the lambda‚Äôs body is
   x, so it just kicks the 1 out. In a sense, applying the Œªx.x
   consumed it. We reduced the amount of structure we had.

   5. Normal order is a common evaluation strategy in lambda
   calculi. Normal order means evaluating (ie, applying or
   beta reducing) the leftmost outermost lambdas first, eval-
   uating terms nested within after you‚Äôve run out of argu-
   ments to apply. Normal order isn‚Äôt how Haskell code is
   evaluated - it‚Äôs call-by-need instead. We‚Äôll explain this more


* Chapter 2
** Infix operators
*** Associativity and precedence
    #+BEGIN_SRC haskell
    :info (^)
    infixr  8   ^
    -- example of infixr
    2 ^ 3 ^ 4 == 2 ^ (3 ^ 4) -- True
    2 ^ 3 ^ 4 == (2 ^ 3) ^ 4 -- False
    -- example of infixl
    2 * 3 * 4 == (2 * 3) * 4 -- True
    #+END_SRC
** mod and rem
   One key difference here is that, in Haskell (not in all lan-
   guages), if one or both arguments are negative, the results of
   mod will have the same sign as the divisor, while the result of
   rem will have the same sign as the dividend:
   
   Prelude> (-5) `mod` 2
   1
   
   Prelude> 5 `mod` (-2)
   -1
   
   Prelude> (-5) `mod` (-2)
   -1
   
   But:
   Prelude> (-5) `rem` 2
   -1
   
   Prelude> 5 `rem` (-2)
   1

   prelude> (-5) `rem` (-2)
   -1

** Let and Where

   /let/ intruduces an expression, but /where/ is a declaration and is bound to
   a surrounding syntactic construct.

** Exercises Chap 2 pag 88-94

** Definitions

   1. The terms argument and parameter are often used inter-
   changeably. However, it is worthwhile to understand the
   distinction. A parameter, or formal parameter, represents a
   value that will be passed to the function when the func-
   tion is called. Thus, parameters are usually variables. An
   argument is an input value the function is applied to. A
   function‚Äôs parameter is bound to the value of an argument
   when the function is applied to that argument.

   2. An /expression/ is a combination of symbols that conforms
   to syntactic rules and can be evaluated to some result. In
   Haskell, an expression is a well-structured combination
   of constants, variables, and functions. While irreducible
   constants are technically expressions, we usually refer to
   those as ‚Äúvalues‚Äù, so we usually mean ‚Äúreducible expres-
   sion‚Äù when we use the term /expression/.

   3. A /value/ is an expression that cannot be reduced or evalu-
   ated any further. 2 * 2 is an expression, but not a value,
   whereas what it evaluates to, 4, is a value.

   4. A /function/ is a mathematical object whose capabilities are
   limited to being applied to an argument and returning a
   result. Functions can be described as a list of ordered pairs
   of their inputs and the resulting outputs, like a mapping.
   Given the function f x = x + 2 applied to the argument
   2, we would have the ordered pair (2, 4) of its input and
   output.

   5. /Infix/ notation is the style used in arithmetic and logic. Infix
   means that the operator is placed between the operands
   or /arguments/. An example would be the plus sign in an
   expression like 2 + 2.

   6. /Operators/ are functions that are infix by default. In Haskell,
   operators must use symbols and not alphanumeric characters.

   7. /Syntactic sugar/ is syntax within a programming language
      designed to make expressions easier to write or read.





* Chapter 3

** Concatenation
  #+BEGIN_SRC haskell
  concat [[1, 2], [2, 3]]
  [1, 2, 2, 3]

  (++) [1, 2, 3] [4, 5, 6]
  [1, 2, 3, 4, 5, 6]

  ["hello" ++ " world"]
  ["hello world"]

  concat ["hello", " world"]
  "hello world"
  #+END_SRC

** More list functions

   - The (:) operator, called /cons/, builds a list
     #+BEGIN_SRC haskell
     'c' : "hris"
     'P' : ""
     #+END_SRC

   - head returns the head or first element of a list:
     #+BEGIN_SRC haskell
     head "Papuchon"
     'P'
     #+END_SRC

   - tail returns the list with the head chopped off:
     #+BEGIN_SRC haskell
     tail "Papuchon"
     "apuchon"
     #+END_SRC

   - take returns the specified number of elements from the list, starting from the left:
     #+BEGIN_SRC haskell
     take 2 "Papuchon"
     "Pa"
     #+END_SRC

   - drop returns the remainder of the list after the specified number of elements has been droped:
     #+BEGIN_SRC haskell
     drop 4 "Papuchon"
     "chon"     drop 9001 "Papuchon"
     ""
     #+END_SRC

   - Infix operator (!!), returns the element that is in the specified position, start from 0:
     #+BEGIN_SRC haskell
     "Papuchon" !! 4
     'c'
     #+END_SRC

*** NOTE

   Note that while all these functions are standard Prelude functions,
   many of them are considered unsafe.
   They are unsafe because they do not cover the case where they are given an
   empty list as input. Instead they throw out an error message, or /exception/.

** EXERCISES Pag 122 -

** Definitions

   - A String is a sequence of characters. In Haskell, String is represented by a
   linked-list of Char values, aka [Char].

   - A type or datatype is a classification of values or data. Types in Haskell
   determine what values are members of the type or that inhabit the type.
   Unlike in other languages, datatypes in Haskell by default do not
   delimit theoperations that can be performed on that data.

   - Concatenation is the joining together of sequences of values.
   Often in Haskell this is meant with respect to the [], or list,
   datatype, which also applies to String which is[Char].
   The concatenation function in Haskell is (++) which has type [a] -> [a] -> [a].

   - Scope is where a variable referred to by name is valid.
   Another word used with the same meaning is visibility,
   because if a variable isn‚Äôt visible it‚Äôs not in scope.

   - Local bindings are bindings local to particular expressions.
   The primary delineation here from top level bindings is that local
   bindings cannot be imported by other programs or modules.

   - Top level bindings in Haskell are bindings that stand outside
   of any other declaration. The main feature of top-level bindings is that
   they can be mande availabe to other modules within your program or to other
   people's programs.



* Chapter 4

** Anatomy of a data declaration

   We will start with a basic datatype to see how datatypes are
   structured and get acquainted with the vocabulary. Bool isn‚Äôt a
   datatype we‚Äôve seen yet in the book, but it provides for truth
   values. It is named after the great logician George Boole and
   the system of logic named for him. Because there are only two
   truth values, there are only two data constructors:

   #+BEGIN_SRC haskell
   data Bool = False | True
   --    [1]    [2] [3] [4]
   #+END_SRC

  1. Type constructor for datatype Bool. This is the name of the type and shows up
  in type signatures.

  2. Data constructor for the value False.

  3. Pipe | indicates a sum type or logical disjunction: or. So, a Bool value is
  True or False.

  4. Data constructor for the value True.

  The whole thing is called a data declaration. Data declarations
  do not always follow precisely the same pattern ‚Äî there
  are datatypes that use logical conjunction (and) instead of disjunction,
  and some type constructors and data constructors may have arguments.

** Fractional Numbers

   Some computations involving numbers will be fractional
   rather than integral. A good example of this is the division
   function (/) which has type:

   (/) :: Fractional a => a -> a -> a

   The notation Fractional a => denotes a typeclass constraint.
   It tells us the type variable /a/ must implement the Fractional typeclass.
   Whatever type of number /a/ turns out to be, it must
   be a type that has an instance of the Fractional typeclass; that
   is, there must be a declaration of how the operations from
   that typeclass will work for the type.

** Comparing Values

   (==) :: Eq a => a -> a -> Bool

   (<) :: Ord a => a -> a -> Bool

   #+BEGIN_SRC haskell
   ['a', 'b'] > ['b', 'a']
   False

   'b' > 'a'
   True

   [1, 2] > [2, 1]
   False

   "Chris" > "Julie"
   False
   #+END_SRC

** Conditionals with if-then-else

   if CONDITION
   then EXPRESSION_A
   else EXPRESSION_B

   Here‚Äôs how it reduces:

   #+BEGIN_SRC haskell
   -- Given:
   x = 0

   if (x + 1 == 1) then "AWESOME" else "wut"
   -- x is zero

   if (0 + 1 == 1) then "AWESOME" else "wut"
   -- reduce 0 + 1 so we can see

   -- if it's equal to 1
   if (1 == 1) then "AWESOME" else "wut"

   -- Does 1 equal 1?
   if True then "AWESOME" else "wut"
   -- pick the branch based on the Bool value
   #+END_SRC
** Tuples
   - The number of values in a tuple is known as the tuple's /arity/.
   - The values within a tuple do not have to be of the same type.
   - The two-tuple is expressed at both the type level and term level with the
     constructor (,). It looks like this:

     #+BEGIN_SRC haskell
     data (,) a b = (,) a b
     #+END_SRC

