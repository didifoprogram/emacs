* Chapter 1
  Œª: expressions, variables, and abstractions

  Expression can be a variable name, an abstractions, or a combination of those things.

  Variables have no meaning or value; placeholders for inputs.

  An abstraction is a function. It is a lambda term that has a
  head (a lambda) and a body and is applied to an argument. An
  argument is an input value.

  The head of the function is a Œª (lambda) followed by a variable
  name. The body of the function is another expression. So, a
  simple function might look like this:

  Œªùë¶.ùë¶

  Œª x . x
  ^‚îÄ‚î¨‚îÄ^
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ extent of the head of the lambda.

  Œª x . x
    ^‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ the single parameter of the
            function. This binds any
            variables with the same name
            in the body of the function.

  Œª x . x
        ^‚îÄ‚îÄ body, the expression the lambda
            returns when applied. This is a
            bound variable.


  The dot (.) separates the parameters of the lambda from
  the function body.

** Beta reduction
   Let‚Äôs use the function we had above:
   Œªùë¶.ùë¶

   We‚Äôll do our first beta reduction using a number.2 We apply
   the function above to 2, substitute 2 for each bound variable
   in the body of the function, and eliminate the head:
   (Œªùë¶.ùë¶) 2

   Let‚Äôs use an example that mixes some arithmetic into our
   lambda calculus. We use the parentheses here to clarify that
   the body expression is ùë¶+1. In other words, we are not applying
   the function to the 1:
   (Œªùë¶.ùë¶ + 1)

   (Œªx.x)(Œªy.y)
   [x := (Œªy.y)] Indicate thath (Œªy.y) will be substituted for all occorrences of x.
           Œªy.y

   (Œªx.x)(Œªy.y)z

   its the same as : ((Œªx.x)(Œªy.y))z

   reduction:

   ((Œªx.x)(Œªy.y))z
   [x := (Œªy.y)]
   (Œªy.y)z
   [y := z]
         z

   Œªx.xy

   The whole abstraction can be applied to an agrument z
   1. (Œªx.xy)z
   2. (Œª[x := z].xy)
   3. zy


   "multiple" argument lambda:
   1. Œªxy.xy
   2. (Œªxy.xy) 1 2
   3. (Œªx.(Œªy.xy)) 1 2
   4. [x ‚à∂= 1]
   5. (Œªy.1y) 2
   6. [y ‚à∂= 2]
   7. 1 2

   Another one:
   1. Œªxy.xy
   2. (Œªxy.xy)(Œªz.a) 1
   3. (Œªx.(Œªy.xy)(Œªz.a)1
   4. [x := (Œªz.a)]
   5. (Œªy.(Œªz.a)y) 1
   6. [y := 1]
   7. (Œªz.a) 1
   8. [z := 1] But there is no z in the body of the functions, so we eliminate the head
   and the result is 'a'.
   9. a


   Another one:
   1. (Œªxyz.xz(yz))(Œªmn.m)(Œªp.p)

   2. (Œªx.Œªy.Œªz.xz(yz))(Œªm.Œªn.m)(Œªp.p)
      We've not reduces or applied anything here, but made the currying explicit.

   3. (Œªy.Œªz.(Œªm.Œªn.m)z(yz))(Œªp.p)
      Our first reduction step was to apply the outermost lambda,
      which was binding the x, to the first argument, (Œªm.Œªn.m).

   4. (Œªz.(Œªm.Œªn.m)(z)((Œªp.p)z))
      We applied the y and replaced the single occurrence of y with the next argument,
      the term (Œªp.p). The outermost lambda binding z is, at this point, irreducible
      because it has no argument to apply to. What remains is to go inside the terms
      one layer at a time until we find something reducible.

   5. Œªz.(Œªn.z)((Œªp.p)z)
      We can apply the lambda binding m to the argument z. The next thing we can apply is
      the lambda binding n to the lambda term ((Œªp.p)z).

   6. Œªz.z
      In the final step, the reduction takes a turn that might look
      slightly odd. Here the outermost, leftmost reducible term
      is Œªn.z applied to the entirety of ((Œªp.p)z). As we saw in
      an example above, it doesn‚Äôt matter what ùëú got bound to,
      Œªn.z unconditionally tosses the argument and returns z.
      So, we are left with an irreducible lambda expression.



** Combinators

   A combinator is a lambda term with no free variables. Combi-
   nators, as the name suggests, serve only to combine the argu-

   When every term in the body occours in the head:

   1. Œªx.x
   2. Œªxy.x
   3. Œªxyz.xz(yz)

   And the following are not combinators because there's one or more free variables

   1. Œªy.x --- x is free
   2. Œªx.xz --- z is free



** Divergence

   Not all reducible lambda terms reduce neatly to a beta normal
   form. This isn‚Äôt because they‚Äôre already fully reduced, but
   rather because they diverge. Divergence here means that the
   reduction process never terminates or ends. Reducing terms
   should ordinarily converge to beta normal form, and diver-
   gence is the opposite of convergence, or normal form. Here‚Äôs
   an example of a lambda term called omega that diverges:

   1. (Œªx.xx)(Œªx.xx)
      x in the first lambda‚Äôs head becomes the second lambda

   2. ([x := (Œªx.xx)]xx)
      Using [var := expr] to denote what x has been bound to.

   3. (Œªx.xx)(Œªx.xx)
      Substituting (Œªx.xx) for each occurence of x. We're back to where
      we started and this redution process never ends
      - we can say omega diverges.

   This matters in programming because terms that diverge
   are terms that don‚Äôt produce an answer or meaningful result.
   Understanding what will terminate means understanding what
   programs will do useful work and return the answer we want.


** Summary

   The main points you should take away from this chapter are:
   ‚Ä¢ Functional programming is based on expressions that in-
   clude variables or constant values, expressions combined
   with other expressions, and functions.

   ‚Ä¢ Functions have a head and a body and are those expres-
   sions that can be applied to arguments and reduced, or
   evaluated, to a result.

   ‚Ä¢ Variables may be bound in the function declaration, and
   every time a bound variable shows up in a function, it has
   the same value.

   ‚Ä¢ All functions take one argument and return one result.

   ‚Ä¢ Functions are a mapping of a set of inputs to a set of
   outputs. Given the same input, they always return the
   same result.


** Look for Exercises in Pag. 28-31


** Definitions

   1. The lambda in lambda calculus is the greek letter Œª used
   to introduce, or abstract, arguments for binding in an expression.

   2. A lambda abstraction is an anonymous function or lambda term
   (Œªx.x + 1)

   The head of the expression, Œªx., abstracts out the term
   x + 1. We can apply it to any x and recompute different results
   for each x we applied the lambda to.

   3. Application is how one evaluates or reduces lambdas, this
   binds the argument to whatever the lambda was applied
   to. Computations are performed in lambda calculus by
   applying lambdas to arguments until you run out of ar-
   guments to apply lambdas to.

   (Œªx.x)1

   This example reduces to 1, the identity Œªx.x was applied
   to the value 1, x was bound to 1, and the lambda‚Äôs body is
   x, so it just kicks the 1 out. In a sense, applying the Œªx.x
   consumed it. We reduced the amount of structure we had.

   5. Normal order is a common evaluation strategy in lambda
   calculi. Normal order means evaluating (ie, applying or
   beta reducing) the leftmost outermost lambdas first, eval-
   uating terms nested within after you‚Äôve run out of argu-
   ments to apply. Normal order isn‚Äôt how Haskell code is
   evaluated - it‚Äôs call-by-need instead. We‚Äôll explain this more

* Chapter 2
** Infix operators
*** Associativity and precedence
    #+BEGIN_SRC haskell
    :info (^)
    infixr  8   ^
    -- example of infixr
    2 ^ 3 ^ 4 == 2 ^ (3 ^ 4) -- True
    2 ^ 3 ^ 4 == (2 ^ 3) ^ 4 -- False
    -- example of infixl
    2 * 3 * 4 == (2 * 3) * 4 -- True
    #+END_SRC
** mod and rem
   One key difference here is that, in Haskell (not in all lan-
   guages), if one or both arguments are negative, the results of
   mod will have the same sign as the divisor, while the result of
   rem will have the same sign as the dividend:

   Prelude> (-5) `mod` 2
   1
   Prelude> 5 `mod` (-2)
   -1
   Prelude> (-5) `mod` (-2)
   -1
   But:
   Prelude> (-5) `rem` 2
   -1
   Prelude> 5 `rem` (-2)
   1
   prelude> (-5) `rem` (-2)
   -1

** Let and Where

   /let/ intruduces an expression, but /where/ is a declaration and is bound to
   a surrounding syntactic construct.

** Exercises Chap 2 pag 88-94

** Definitions

   1. The terms argument and parameter are often used inter-
   changeably. However, it is worthwhile to understand the
   distinction. A parameter, or formal parameter, represents a
   value that will be passed to the function when the func-
   tion is called. Thus, parameters are usually variables. An
   argument is an input value the function is applied to. A
   function‚Äôs parameter is bound to the value of an argument
   when the function is applied to that argument.

   2. An /expression/ is a combination of symbols that conforms
   to syntactic rules and can be evaluated to some result. In
   Haskell, an expression is a well-structured combination
   of constants, variables, and functions. While irreducible
   constants are technically expressions, we usually refer to
   those as ‚Äúvalues‚Äù, so we usually mean ‚Äúreducible expres-
   sion‚Äù when we use the term /expression/.

   3. A /value/ is an expression that cannot be reduced or evalu-
   ated any further. 2 * 2 is an expression, but not a value,
   whereas what it evaluates to, 4, is a value.

   4. A /function/ is a mathematical object whose capabilities are
   limited to being applied to an argument and returning a
   result. Functions can be described as a list of ordered pairs
   of their inputs and the resulting outputs, like a mapping.
   Given the function f x = x + 2 applied to the argument
   2, we would have the ordered pair (2, 4) of its input and
   output.

   5. /Infix/ notation is the style used in arithmetic and logic. Infix
   means that the operator is placed between the operands
   or /arguments/. An example would be the plus sign in an
   expression like 2 + 2.

   6. /Operators/ are functions that are infix by default. In Haskell,
   operators must use symbols and not alphanumeric characters.

   7. /Syntactic sugar/ is syntax within a programming language
      designed to make expressions easier to write or read.


* Chapter 3

** Concatenation
  #+BEGIN_SRC haskell
  concat [[1, 2], [2, 3]]
  [1, 2, 2, 3]

  (++) [1, 2, 3] [4, 5, 6]
  [1, 2, 3, 4, 5, 6]

  ["hello" ++ " world"]
  ["hello world"]

  concat ["hello", " world"]
  "hello world"
  #+END_SRC

** More list functions

   - The (:) operator, called /cons/, builds a list
     #+BEGIN_SRC haskell
     'c' : "hris"
     'P' : ""
     #+END_SRC

   - head returns the head or first element of a list:
     #+BEGIN_SRC haskell
     head "Papuchon"
     'P'
     #+END_SRC

   - tail returns the list with the head chopped off:
     #+BEGIN_SRC haskell
     tail "Papuchon"
     "apuchon"
     #+END_SRC

   - take returns the specified number of elements from the list, starting from the left:
     #+BEGIN_SRC haskell
     take 2 "Papuchon"
     "Pa"
     #+END_SRC

   - drop returns the remainder of the list after the specified number of elements has been droped:
     #+BEGIN_SRC haskell
     drop 4 "Papuchon"
     "chon"     drop 9001 "Papuchon"
     ""
     #+END_SRC

   - Infix operator (!!), returns the element that is in the specified position, start from 0:
     #+BEGIN_SRC haskell
     "Papuchon" !! 4
     'c'
     #+END_SRC

*** NOTE

   Note that while all these functions are standard Prelude functions,
   many of them are considered unsafe.
   They are unsafe because they do not cover the case where they are given an
   empty list as input. Instead they throw out an error message, or /exception/.

** EXERCISES Pag 122 -

** Definitions

   - A String is a sequence of characters. In Haskell, String is represented by a linked-list of Char values, aka [Char].

   - A type or datatype is a classification of values or data. Types in Haskell
   determine what values are members of the type or that inhabit the type.
   Unlike in other languages, datatypes in Haskell by default do not
   delimit theoperations that can be performed on that data.

   - Concatenation is the joining together of sequences of values.
   Often in Haskell this is meant with respect to the [], or list,
   datatype, which also applies to String which is[Char].
   The concatenation function in Haskell is (++) which has type [a] -> [a] -> [a].

   - Scope is where a variable referred to by name is valid.
   Another word used with the same meaning is visibility,
   because if a variable isn‚Äôt visible it‚Äôs not in scope.

   - Local bindings are bindings local to particular expressions.
   The primary delineation here from top level bindings is that local
   bindings cannot be imported by other programs or modules.

   - Top level bindings in Haskell are bindings that stand outside
   of any other declaration. The main feature of top-level bindings is that
   they can be mande availabe to other modules within your program or to other
   people's programs.

* Chapter 4

** Anatomy of a data declaration

   We will start with a basic datatype to see how datatypes are
   structured and get acquainted with the vocabulary. Bool isn‚Äôt a
   datatype we‚Äôve seen yet in the book, but it provides for truth
   values. It is named after the great logician George Boole and
   the system of logic named for him. Because there are only two
   truth values, there are only two data constructors:

   #+BEGIN_SRC haskell
   data Bool = False | True
   --    [1]    [2] [3] [4]
   #+END_SRC

  1. Type constructor for datatype Bool. This is the name of the type and shows up
  in type signatures.

  2. Data constructor for the value False.

  3. Pipe | indicates a sum type or logical disjunction: or. So, a Bool value is
  True or False.

  4. Data constructor for the value True.

  The whole thing is called a data declaration. Data declarations
  do not always follow precisely the same pattern ‚Äî there
  are datatypes that use logical conjunction (and) instead of disjunction,
  and some type constructors and data constructors may have arguments.

** Fractional Numbers

   Some computations involving numbers will be fractional
   rather than integral. A good example of this is the division
   function (/) which has type:

   (/) :: Fractional a => a -> a -> a

   The notation Fractional a => denotes a typeclass constraint.
   It tells us the type variable /a/ must implement the Fractional typeclass.
   Whatever type of number /a/ turns out to be, it must
   be a type that has an instance of the Fractional typeclass; that
   is, there must be a declaration of how the operations from
   that typeclass will work for the type.

** Comparing Values

   (==) :: Eq a => a -> a -> Bool

   (<) :: Ord a => a -> a -> Bool

   #+BEGIN_SRC haskell
   ['a', 'b'] > ['b', 'a']
   False

   'b' > 'a'
   True

   [1, 2] > [2, 1]
   False

   "Chris" > "Julie"
   False
   #+END_SRC

** Conditionals with if-then-else

   if CONDITION
   then EXPRESSION_A
   else EXPRESSION_B

   Here‚Äôs how it reduces:

   #+BEGIN_SRC haskell
   -- Given:
   x = 0

   if (x + 1 == 1) then "AWESOME" else "wut"
   -- x is zero

   if (0 + 1 == 1) then "AWESOME" else "wut"
   -- reduce 0 + 1 so we can see

   -- if it's equal to 1
   if (1 == 1) then "AWESOME" else "wut"

   -- Does 1 equal 1?
   if True then "AWESOME" else "wut"
   -- pick the branch based on the Bool value
   #+END_SRC
** Tuples
   - The number of values in a tuple is known as the tuple's /arity/.
   - The values within a tuple do not have to be of the same type.
   - The two-tuple is expressed at both the type level and term level with the
     constructor (,). It looks like this:

     #+BEGIN_SRC haskell
     data (,) a b = (,) a b

     (,) 8 10
     (8,10)

     (,) 8 "Julie"
     (8,"Julie")

     -- Two-tuple has some default convenience functions
     fst :: (a,b) -> a
     snd :: (a,b) -> b

     let myTup = (1 :: Integer, "blah")

     -- You can do
     import Data.Tuple
     swap myTup
     -- The result is:
     ("blah",1)

     -- We can also combine tuples with other expressions:
     2 + fst (1, 2)
     3

     2 + snd (1, 2)
     4

     -- patern matching on tuples:
     tupFunc :: (Int, [a]) -> (Int, [a]) -> (Int, [a])
     tupFunc (a, b) (c, d) = ((a + c), (b ++ d))

     #+END_SRC

** Lists

   - All elements of a list must be of the same type.
   - Lists have their own distinct [] syntax.
   - The number of values that will be in the list isn't specified in the type,
     unlike tuples where the arity is set in the type and immutable.

     #+BEGIN_SRC haskell
     p = "Papuchon"
     awesome = [p, "curry", ":)"]
     also = ["Quake", "The Simons"]

     -- (++) :: [a] -> [a] -> [a]
     awesome ++ also

     -- allAwesome :: [[[Char]]]
     allAwesome = [awesome, also]

     -- concat :: [[a]] -> [a]
     concat allAwesome
     #+END_SRC

** Exercises
   #+BEGIN_SRC haskell
   -- Exercise 10 pag 170
   f :: (a, b) -> (c, d) -> ((b, d), (a, c))
   f x y = ((snd x, snd y), (fst x, fst y))
   #+END_SRC

   - Correcting syntax
     #+BEGIN_SRC haskell
     -- Ex 1
     x = (+)
     adds xs = x w  1
     where w = length xs

     -- Ex 2
     id x = x

     -- Ex 3
     f (a, b) = fst (a, b)
     #+END_SRC
** Definitions

   - A /tuple/ is an ordered grouping of values. In Haskell, you
   cannot have a tuple with only one element, but there is a
   zero tuple also called unit or (). The types of the elements
   of tuples are allowed to vary, so you can have both (String,
   String) or (Integer, String). Tuples in Haskell are the usual
   means of briefly carrying around multiple values without
   giving that combination its own name.

   - A typeclass is a set of operations defined with respect to
   a polymorphic type. When a type has an instance of a
   typeclass, values of that type can be used in the standard
   operations defined for that typeclass. In Haskell, typeclasses
   are unique pairings of class and concrete instance.
   This means that if a given type /a/ has an instance of Eq, it
   has /only one instance of Eq.

   - Data constructors in Haskell provide a means of creating
   values that inhabit a given type. Data constructors in
   Haskell have a type and can either be constant values
   (nullary) or take one or more arguments, like functions.

   In the following example, Cat is a nullary data constructor
   for Pet and Dog is a data constructor that takes an argument:
   #+BEGIN_SRC haskell
   type Name = String

   data Pet = Cat | Dog Name
   #+END_SRC

   The data constructors have the following types:
   Prelude> :t Cat
   Cat :: Pet
   Prelude> :t Dog
   Dog :: Name -> Pet

   - Type constructors in Haskell are not values and can only be
   used in type signatures. Just as data declarations generate
   data constructors to create values that inhabit that type,
   data declarations generate type constructors which can be
   used to denote that type. In the above example, Pet is the
   type constructor. A guideline for differentiating the two
   kinds of constructors is that type constructors always go
   to the left of the = in a data declaration.

   - /Data declarations/ define new datatypes in Haskell. Data
   declarations /always/ create a new type constructor, but may
   or may not create new data constructors. Data declarations
   are how we refer to the entire definition that begins with
   the data keyword.

   - A type alias is a way to refer to a type constructor or type
   constant by an alternate name, usually to communicate something
   more specific or for brevity.
   #+BEGIN_SRC haskell
   type Name = String
   -- creates a new type alias Name of the
   -- type String *not* a data declaration,
   -- just a type alias declaration
   #+END_SRC

   - /Arity/ is the number of arguments a function accepts. This
   notion is a little slippery in Haskell as, due to currying, all
   functions are 1-arity and we handle accepting multiple
   arguments by nesting functions.

   - Polymorphism in Haskell means being able to write code
   in terms of values which may be one of several, or any,
   type. Polymorphism in Haskell is either parametric or
   constrained. The identity function, id, is an example of a
   parametrically polymorphic function:
   #+BEGIN_SRC haskell
   id :: a -> a
   id x = x
   #+END_SRC
   Here id works for a value of /any/ type because is doesn't use
   any information specific to a given type or set  of types.

   Another example:
   #+BEGIN_SRC haskell
   isEqual :: Eq a => a -> a -> Bool
   isEqual x y = x == y
   #+END_SRC
   isEqual is polymorphico, but /constrained/ or /bounded/ to the set of
   types which have an instance of the Eq typeclass.

** Names and variables
*** Names
    In Haskell there are seven categories of entities that have
    names: functions, term-level variables, data constructors, type
    variables, type constructors, typeclasses, and modules. Term-
    level variables and data constructors exist in your terms. Term
    level is where your values live and is the code that executes
    when your program is running. At the type level, which is used
    during the static analysis & verification of your program, we
    have type variables, type constructors, and typeclasses. Lastly,
    for the purpose of organizing our code into coherent groupings
    across different files, we have modules.

* Chapter 5

** The Function Type
   #+BEGIN_SRC haskell
   fst :: (a,b)  ->   a
   --      [1]  [2]  [3]
   #+END_SRC
   1. The first parameter of fst has the type (a, b). Note that
   the tuple type itself (,) takes two arguments /a/ and /b/.

   2. The function type, (->), has two parameters. One is (a,b)
   and one is result /a/.

   3. The result of the function, which has type /a/. It‚Äôs the same
   /a/ that was in the tuple (a, b).

** Currying
   Currying refers to the nesting of multiple functions, each accepting one
   argument and returning one result, to allow the illusion of multiple-parameter functions.
   #+BEGIN_SRC haskell
   data (->) a b
   #+END_SRC
   - If you are constructing a function that requires multiple parameters,
   then the /b/ can be another function (the /a/ can be another function as well).
   In that case, just like in lambda abstractions that have multiple heads, they are nested.

   - Let's check the type signature for addition:
     #+BEGIN_SRC haskell
     (+) :: Num a => a -> a -> a
     #+END_SRC
   - Functions in Haskell are nested like Matryoshka
   dolls in order to accept ‚Äúmultiple‚Äù arguments. The way
   the (->) type constructor for functions works means a -> a -> a
   represents successive function applications, each
   taking one argument and returning one result. The difference
   is that the function at the outermost layer is returning
   another function that accepts the next argument.
   This is called currying.

   - The (->) is an infix operator and right associative, so:
   #+BEGIN_SRC haskell
   map :: (a -> b) -> [a] -> [b]

   -- associates into
   map :: (a -> b) -> ([a] -> [b])
   #+END_SRC
   - This is to group the parameters into argument and result, since there can only
   be one argument and one result per arrow. Since all the arrows have the same precedence,
   the associativity does not change the precedence or order of evaluation.

   - Remember, when we have a lambda expression that appears to have two parameters,
   they are nested lambdas. Applying the expression to one argument returns a function that
   awaits application to a second argument.

   - The type constructor for functions and the types we sse above are the same thing,
   but written in Haskell. When there are ‚Äútwo arguments‚Äù in Haskell,
   we apply our function to an argument, just like when we apply a lambda expression to an
   argument, and then return a result that is a function and needs to be applied to a second argument.

** Partial application

   #+BEGIN_SRC haskell
   (+) :: Num a => a -> a -> a
   sumA = (+) 10
   sumB x = sumA x
   -- sumB is equal to 22

   addStuff :: Integer -> Integer -> Integer
   -- its the same as:
   addStuff :: Integer -> (Integer -> Integer)
   #+END_SRC
** Manual currtying and uncurrying
   - /Uncurrying/ means un-nesting the functions and replacing the two functions with a tuple
     of two values.

   - If you uncurry (+), the type changes from Num a => a -> a -> a to Num a => (a,a) -> a
     which better fits the description "takes two arguments, returns one result".

   - Uncurried functions: One function, many arguments.

   - Curried functions: Many functions, one argument apiece.

     #+BEGIN_SRC haskell
     nonsense :: Bool -> Integer
     nonsense True = 805
     nonsense False = 31337

     curriedFunction :: Integer -> Bool -> Integer
     curriedFunction i b = i + (nonsense b)

     uncurriedFunction :: (Integer, Bool) -> Integer
     uncurriedFunction (i,b) = i + (nonsense b)

     anonymous :: Integer -> Bool -> Integer
     anonymous = \i b -> i + (nonsense b)

     anonNested :: Integer -> Bool -> Integer
     anonNested = \i -> \b -> i + (nonsense b)
     #+END_SRC

     - Functions that /seem/ to accept multiple arguments such as with a -> a -> a -> a are
       /higher-order functions/: they yield more functions values as each argument is applied
       until there are no more (->) type constructors and it terminates in a non-function value.

** Currying and uncurrying existing functions

  - Consider the following example for currying:
    Prelude> let curry f a b = f (a, b)
    Prelude> :t curry
    curry :: ((t1, t2) -> t) -> t1 -> t2 -> t
    Prelude> :t fst
    fst :: (a, b) -> a
    Prelude> :t curry fst
    curry fst :: t -> b -> t
    Prelude> fst (1, 2)
    1
    Prelude> curry fst 1 2
    1

  - Then for uncurrying:
    Prelude> let uncurry f (a, b) = f a b
    Prelude> :t uncurry
    uncurry :: (t1 -> t2 -> t) -> (t1, t2) -> t
    Prelude> :t (+)
    (+) :: Num a => a -> a -> a
    Prelude> (+) 1 2
    3
    Prelude> uncurry (+) (1,2)
    3
** Sectioning

   - The term /sectioning/ specifically refers to partial application of infix operators,
     which has a special syntax and allows you to choose whether the argument you're partially
     applying the operator to is the first or second argument:

     Prelude> let x = 5
     Prelude> let y = (2^)
     Prelude> let z = (^2)
     Prelude> y x
     32
     Prelude> z x
     25

     This does not only work with arithmetic:

     Prelude> let celebrate = (++ " woot!")
     Prelude> celebrate "naptime"
     "naptime woot!"
     Prelude> celebrate "dogs"
     "dogs woot!"

** Exercises: pag 204
   #+BEGIN_SRC haskell
   -- Ex 7
   kessel :: (Ord a, Num b) => a -> b -> a; kessel = undefined
   kessel 1 2 :: (Num a, Ord a) => a
   #+END_SRC
** Polymorphism
** Exercises: Parametricity pag 213
** Polymorphic constants
   #+BEGIN_SRC haskell
   (-10) -- is a polymorphic constant. It will have to resolve into a concrete type at some point.

   -- We can force the compiler to be more specific about the types of numbers:
   x = 5 + 5 :: Int
   #+END_SRC

** Type inference
** Exercises pag 221
** Chapter Exercises
